#!/bin/sh
# Systemd sleep hook to fix T2 keyboard delay on resume
# This script unbinds/rebinds the keyboard USB device to force immediate reinitialization
# Managed by chezmoi - do not edit directly in /etc/systemd/system-sleep/

# Ensure the tools we need are on PATH when running from systemd
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Log file path for human-readable history (overridable via FIX_T2_KEYBOARD_LOG_FILE)
: "${FIX_T2_KEYBOARD_LOG_FILE:=/var/log/fix-t2-keyboard.log}"

log() {
  message="$*"

  logger -t fix-t2-keyboard "$message" 2>/dev/null || true

  # Always mirror log entries to an accessible file for post-resume debugging.
  log_dir=${FIX_T2_KEYBOARD_LOG_FILE%/*}
  if [ "$log_dir" != "$FIX_T2_KEYBOARD_LOG_FILE" ]; then
    mkdir -p "$log_dir" 2>/dev/null || true
  fi

  if [ ! -e "$FIX_T2_KEYBOARD_LOG_FILE" ]; then
    touch "$FIX_T2_KEYBOARD_LOG_FILE" 2>/dev/null || true
    chmod 0644 "$FIX_T2_KEYBOARD_LOG_FILE" 2>/dev/null || true
  fi

  printf '%s %s\n' "$(date '+%F %T')" "$message" >>"$FIX_T2_KEYBOARD_LOG_FILE" 2>/dev/null || true

  # Echo to stdout when running interactively (useful for manual tests).
  if [ -t 1 ]; then
    printf '%s\n' "$message"
  fi
}

# Debug: log all invocations
log "Script called with args: $1 $2"

case "$1" in
  post)
    # After resume, find and rebind the keyboard device in background
    # The keyboard is part of the BCE virtual HCI controller
    # Run in background to prevent blocking suspend/resume
    (
      exec 2>/dev/null

      log "Post-resume hook starting"

      # Give kernel drivers a moment to settle before poking at devices
      sleep 1

      log "Waiting for USB devices to settle"
      if command -v udevadm >/dev/null 2>&1; then
        udevadm settle --timeout=3 >/dev/null 2>&1 || true
      fi

      attempts=0
      max_attempts=5

      while [ "$attempts" -lt "$max_attempts" ]; do
        attempts=$((attempts + 1))
        log "Resume attempt $attempts: scanning for Apple Internal Keyboard / Trackpad devices"

        found_any=0
        success_any=0

        for device in /sys/bus/usb/devices/*/product; do
          [ -f "$device" ] || continue

          product_name=$(cat "$device" 2>/dev/null | tr -d '\r')
          device_path=$(dirname "$device")
          device_name=$(basename "$device_path")

          # Only target the internal keyboard/trackpad path
          if printf '%s' "$product_name" | grep -q "Apple Internal Keyboard"; then
            found_any=1

            log "Attempting rebind for $device_name ('$product_name')"

            if timeout 3 sh -c "printf '%s' '$device_name' > /sys/bus/usb/drivers/usb/unbind"; then
              log "Unbound $device_name"
            else
              log "Unbind timed out or failed for $device_name"
              continue
            fi

            sleep 0.5

            if timeout 3 sh -c "printf '%s' '$device_name' > /sys/bus/usb/drivers/usb/bind"; then
              success_any=1
              log "Rebound $device_name successfully"
            else
              log "Rebind timed out or failed for $device_name"
            fi
          fi
        done

        if [ "$found_any" -eq 0 ]; then
          log "No Apple Internal devices detected on attempt $attempts"
        fi

        if [ "$success_any" -eq 1 ]; then
          if systemctl restart keyd >/dev/null 2>&1; then
            log "Restarted keyd service after resume"
          else
            log "Failed to restart keyd service"
          fi
          log "Rebind successful; exiting hook"
          exit 0
        fi

        sleep 1
      done

      log "Keyboard device not found after resume attempts"
    ) &

    # Don't wait for background job - exit immediately to not block systemd
    ;;
esac
